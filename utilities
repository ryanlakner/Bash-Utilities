#!/usr/bin/env bash

# Bash Script Utilities (or functions)
# Author: Ryan Lakner

# Colors
BLACK="\033[30m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
PURPLE="\033[35m"
CYAN="\033[36m"
WHITE="\033[37m"
GREY="\033[90m"

info() {
    printf "${BLUE}❯ ${WHITE}${@}\n"
}

upclear() {
    printf "\033[A\r\033[2K"
}

title() {
    local width=34
    local label="Script: $(basename "$0")"
    if (( ${#label} >= width )); then
        printf '%s\n' "$label"
        return
    fi
    local half=$(( ${#label} / 2 ))
    local pad_left=$(( width - half ))
    clear
    line
    echo ''
    echo -e "${BLUE}"
    echo '    ____  ___________    _____       ______                         '
    echo '   / __ \/ ____/ ___/   / ___/____  / __/ /__      ______ _________ '
    echo '  / /_/ / /    \__ \    \__ \/ __ \/ /_/ __/ | /| / / __ `/ ___/ _ \'
    echo ' / ____/ /___ ___/ /   ___/ / /_/ / __/ /_ | |/ |/ / /_/ / /  /  __/'
    echo '/_/    \____//____/   /____/\____/_/  \__/ |__/|__/\__,_/_/   \___/ ©'
    echo -e "${WHITE}"
    printf '%*s%s\n' "$pad_left" "" "$label"
    echo ''
    line
}


seek() {
    local variable=$1
    local prompt="$2"
    printf "$BLUE❯ $WHITE$prompt: "
    read -p "" $variable
}

confirm() {
    while true; do
        printf "${BLUE}? ${WHITE}Continue [Y/N]:\n"
        printf "${BLUE}❯ ${WHITE}"
        read choice
        case "$choice" in
            [Yy] | [Yy][Ee][Ss] )
                upclear
                printf "${BLUE}❯ ${GREEN}yes${WHITE}\n"
                return 0 ;;
            [Nn] | [Nn][Oo] )
                upclear
                printf "${BLUE}❯ ${RED}no${WHITE}\n"
                return 1 ;;
            * )
                fail "Invalid"
                continue ;;
        esac
    done
}

warn() {
    printf "$YELLOW! ${@} !$WHITE\n"
}

success() {
    printf "$GREEN✓ $WHITE${@}\n"
}

fail() {
    printf "$RED✗ $WHITE${@}\n"
}

spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    tput civis  # Hide cursor
    while [ "$(ps a | awk '{print $1}' | grep "$pid")" ]; do
        local temp=${spinstr#?}
        printf "[%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    tput cnorm  # Show cursor
    printf "    \b\b\b\b"  # Clean up spinner
}

progress-bar() {
    local current=$1
    local len=$2
    local bar_char='|'
    local empty_char=' '
    local length=50
    local perc_done=$((current * 100 / len))
    local num_bars=$((perc_done * length / 100))

    local i
    local s='['
    for ((i = 0; i < num_bars; i++)); do
        #s+=$'\e[31'$bar_char$'\e[0'
        s+=$bar_char
    done
    for ((i = num_bars; i< length; i++)); do
        s+=$empty_char
    done
    s+=']'

    #echo -ne "$s $current/$len ($perc_done%)\r"
    echo -ne "$s ($perc_done%)\r"
}

line() {
    echo -e "${PURPLE}─────────────────────────────────────────────────────────────────${WHITE}"
}

box() {
    local title=""
    local OPTIND opt
    
    # Parse options: -t "Title"
    while getopts "t:" opt; do
        case $opt in
            t) title="$OPTARG" ;;
            *) ;;
        esac
    done
    shift $((OPTIND -1))
    
    # Read text, support multi-line
    local text="$*"
    local IFS=$'\n'
    local lines=($text)
    
    # Compute max line length
    local max_length=0
    for line in "${lines[@]}"; do
        (( ${#line} > max_length )) && max_length=${#line}
    done
    
    # Adjust title if provided
    local title_text=""
    if [[ -n "$title" ]]; then
        title_text="─$title"
    fi
    
    # Compute box width
    local padding=1
    local total_length=$(( max_length + padding * 2 ))
    
    # Top border with optional title
    printf '┌─'
    if [[ -n "$title_text" ]]; then
        printf '%s' "$title_text"
        local rem=$(( total_length - ${#title_text} - 1 ))
        printf '─%.0s' $(seq 1 $rem)
    else
        local rem=$(( total_length - 1 ))
        printf '─%.0s' $(seq 1 $rem)
    fi
    printf '┐\n'
    
    # Content lines (corrected!)
    for line in "${lines[@]}"; do
        local line_length=${#line}
        local space_after=$(( total_length - line_length - 1))
        printf '│ '
        printf "%s" "$line"
        printf ' %.0s' $(seq 1 $space_after)
        printf '│\n'
    done
    
    # Bottom border
    printf '└'
    printf '─%.0s' $(seq 1 $total_length)
    printf '┘\n'
}
